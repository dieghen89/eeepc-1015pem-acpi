#!/bin/bash
. /etc/conf.d/eeepc-1015pem-acpi.conf
export DISPLAY=:0.0
#Set the logfile position and the date format
logfile="/var/log/eeepc-acpi.log"
logdate="$(date +'[%d-%m-%y %k:%M]')"
sendlog()
{
	echo -e "$logdate $1" >> $logfile
}

#If the file doesn't exist
if [ ! -e $logfile ] ; then
	echo -e "#This is the log of eeepc-1015pem-acpi" > $logfile
	echo -e "#" >> $logfile
	echo -e "" >> $logfile
fi

#If the file is larger than 4MB
if [ "$(stat -c %s $logfile)" -gt "4194304" ] ; then
	rm /var/log/eeepc-acpi.log
fi


# She value
SHE_DIR="/sys/devices/platform/eeepc/cpufv"
she_value=`cat $SHE_DIR`

# Cpu governor value
gov_value=`cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor`

# Count of the number of the preset in config file
for preset in ${NAME[*]} ; do
	preset_num=$(($preset_num+1))
done

# Function to set the right user if not set in the conf file
user() {
	if [ "a$USER" = "a" ] ; then
		if [ "$(who | wc -l)" = "1" ] ; then
			USER="$(who | awk '{print $1}')"
		else
			sendlog "[WW] You have more than one user logged in!"
			sendlog "[WW] Please set your user name in"
			sendlog "[WW] /etc/conf.d/eeepc-1015pem-acpi.conf"
		fi
	else 
		if [ $(who | grep $USER | wc -l) == 0 ] ; then
			sendlog "[WW] You have setted the wrong user in"
			sendlog "[WW] /etc/conf.d/eeepc-1015pem-acpi.conf"
			sendlog "[WW] or you are logged with another user"
		fi 
	fi
}

# Function used to send a notification, checking the
# conf file to choose the right notification system
notify() {
	user
	case $1 in
		touchpad) [ $NOTIFY_DE = "gtk" ] && execute "@notify-send 'Touchpad' '$touch_not'"
							[ $NOTIFY_DE = "qt" ] && execute "@kdialog --passivepopup '$touch_not' --title 'Touchpad'"
	;;
		she)	[ $NOTIFY_DE = "gtk" ] && execute "@notify-send 'SHE:' '$she_old --> $she_new'"
					[ $NOTIFY_DE = "qt" ] && execute "@kdialog --passivepopup '$she_old --> $she_new' --title 'SHE:'"
		;;
		preset)	[ $NOTIFY_DE = "gtk" ] && execute "@notify-send 'PRESET:' '$preset_old --> $preset_new'"
						[ $NOTIFY_DE = "qt" ] && execute "@kdialog --passivepopup '$preset_old --> $preset_new' --title 'PRESET:'"
		;;
	esac
}

# Function to toggle the FSB clock through
# the Asus Super Hybrid Engine
she_toggle() {
# Check if the $1 is empty and do a cyclic toggle
	if [ a$1 = "a" ] ; then
		case "$(cat $SHE_DIR)" in
			0x300)	# To Powersave
				echo 2 > $SHE_DIR
				she_new="Powersave"
				she_old="Performance"
				notify she
		;;
			0x301)	# To Performance 
				echo 0 > $SHE_DIR
				she_new="Performance"
				she_old="Normal"
				notify she
		;;
			0x302)	# To Normal
				echo 1 > $SHE_DIR
				she_new="Normal"
				she_old="Powersave"
				notify she
		;;
		*)	echo 1 > $SHE_DIR
				she_new="Normal"
      			she_old=""
				notify she
		;;
		esac
		sendlog "SHE: $she_old --> $she_new"
	else
		case $1 in
			powersave) echo 2 > $SHE_DIR
			;;
			normal) echo 1 > $SHE_DIR
			;;
			performance) echo 0 > $SHE_DIR
			;;
		esac
	fi
}

# Function that rotate the existing presets.
preset_toggle()
{
	#TODO file temp non esistente
	#check_preset
	CURRENT_PRESET=`cat /tmp/eeepc-current-preset | grep Preset | awk '{print $2}'`
	preset_old=`eval echo \${NAME[$CURRENT_PRESET]}`

	# I don't know how many presets are declared in .conf file
	# Dynamic creation of the next preset number:
	NEXT_PRESET=$(( ($CURRENT_PRESET % $preset_num) + 1 % preset_num))
	preset_new=`eval echo \${NAME[$NEXT_PRESET]}`

	# Load next preset
	eeepc-power-manager.sh -p $preset_new

	# Change the current preset in tmp file
	echo -e "Preset $NEXT_PRESET \nName $preset_new" > /tmp/eeepc-current-preset

	# Send notification
	notify preset
	# Send log
	sendlog "PRESET: $preset_old --> $preset_new"
	sendlog "== SHE: `eval echo \${SHE[$CURRENT_PRESET]}` --> `eval echo \${SHE[$NEXT_PRESET]}`"
	sendlog "== CPU: `eval echo \${CPU_GOV[$CURRENT_PRESET]}` --> `eval echo \${CPU_GOV[$NEXT_PRESET]}`"
	sendlog "== SYS_PROC_TWEAK: `eval echo \${SYS_PROC_TWEAK[$CURRENT_PRESET]}` \
--> `eval echo \${SYS_PROC_TWEAK[$NEXT_PRESET]}`"
}

# Function that switch all the present CPU to a governor given as $1
apply_CPU()
{
	cf_path=/sys/devices/system/cpu/cpufreq/
	GOVERNOR=$1
	[[ "$1" = "conservative_lpow" || "$1" == "conservative_hpow" ]] && GOVERNOR=conservative
	for i in $(seq 0 $((`cat /proc/cpuinfo | grep processor | wc -l`-1))) ; do
		echo $GOVERNOR > /sys/devices/system/cpu/cpu$i/cpufreq/scaling_governor
	done

	tweak_gov()
	{
		echo $UP_THRESHOLD > /sys/devices/system/cpu/cpufreq/$GOVERNOR/up_threshold
		echo $DOWN_THRESHOLD > /sys/devices/system/cpu/cpufreq/$GOVERNOR/down_threshold
		echo $SAMPLING_DOWN_FACTOR > /sys/devices/system/cpu/cpufreq/$GOVERNOR/sampling_down_factor
		echo $FREQ_STEP > /sys/devices/system/cpu/cpufreq/$GOVERNOR/freq_step
	}

	case $1 in
		conservative_lpow) # Tweaks for conservative_lpow CPU governor:
			UP_THRESHOLD=80
			DOWN_THRESHOLD=40
			SAMPLING_DOWN_FACTOR=1
			FREQ_STEP=20
			tweak_gov
		;;
		conservative_hpow) # Tweaks for conservative_hpow CPU governor:
			UP_THRESHOLD=55
			DOWN_THRESHOLD=15 # 10 not valid
			SAMPLING_DOWN_FACTOR=5
			FREQ_STEP=50
			tweak_gov
		;;
		powersave|conservative|performance)
		;;
		*) sendlog "[WW] unknown CPU governor"
		;;
	esac
}

# Function that read the .conf file and load the right
# CPU / SHE governor and the sys_proc tweak enable/disable
apply_preset()
{
	# CPU governor:
	apply_CPU `eval echo \${CPU_GOV[$1]}`
	# SHE governor:
	she_toggle `eval echo \${SHE[$1]}`
	# Tweak some /sys and /proc entry
	if [ `eval echo \${SYS_PROC_TWEAK[$1]}` == "yes" ] ; then
		sh /etc/acpi/eeepc/eeepc-sys_proc_tweaks.sh powersave
	else
		sh /etc/acpi/eeepc/eeepc-sys_proc_tweaks.sh performance
	fi
	# Send the preset name to a temp file
	echo -e "Preset $1 \nName `eval echo \${NAME[$1]}`" > /tmp/eeepc-current-preset
	# Send log
	sendlog "PRESET: --> `eval echo \${NAME[$1]}`"
	sendlog "== SHE: --> `eval echo \${SHE[$1]}`"
	sendlog "== CPU: --> `eval echo \${CPU_GOV[$1]}`"
	sendlog "== SYS_PROC_TWEAK: --> `eval echo \${SYS_PROC_TWEAK[$1]}`"
}

execute()
{
	user
	cmd=( "$@" )
	if [ "${cmd:0:1}" == "@" ]; then
		DISPLAY=:0.0 su $USER -c "${cmd:1} &"
		echo ${cmd:1}
	else
		eval $cmd
	fi
}

# Function to toggle the touchpad, via synclient (xf86-input-synaptics)
touchpad_toggle() {
	TOUCH_STATUS=$(execute @synclient | grep TouchpadOff | awk '{print $3}')
	echo "touch = $TOUCH_STATUS"
	if [ $TOUCH_STATUS == 0 ] ; then
		execute "@synclient TouchpadOff=1"
		touch_not="disabled"
		notify touchpad
		sendlog "Touchpad disabled"
	else
		execute "@synclient TouchpadOff=0"
		touch_not="enabled"
		notify touchpad
		sendlog "Touchpad enabled"
	fi
}
